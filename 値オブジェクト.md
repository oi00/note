# 値オブジェクト  
**値オブジェクトはシステム固有の値を作る**
## 値の性質
- 不変である  
変数は代入可能であるが、定数は代入不可能である。  
値オブジェクトは定数に近い性質を持つイメージ。  
つまり、クラスとして生成される値オブジェクトは、コンストラクタで値を設定したら、その後は変更できない。
```C#:title
＜変数＞
var greet = "こんにちは";
greet. ChangeTo(" Hello"); // このようなメソッドは本来存在しない 
Console. WriteLine( greet); // Helloが表示される

＜定数＞
"こんにちは". ChangeTo(" Hello"); // このようなメソッドは本来存在しない 
Console. WriteLine(" こんにちは"); // Helloが表示されるという感覚にはならない
```  
- 交換が可能である  
値オブジェクトを変更したい場合は、そのオブジェクト自体を入れ替える。  
つまり、代入によって変更する。
```C#:title
string text = "Hello";
text = "こんにちは"; // 『Hello』が『こんにちは』に交換されている
```
- 等価性によって比較される  
数値同士の比較や、文字列同士の比較のように、値オブジェクト同士の比較が可能である。  
つまり、値オブジェクトのクラスには＝(Equals)の定義が必要になる。

<br>

## 値オブジェクトを作成する基準
- ルールが存在しているか  
そのモノが特定のルールで成り立っている場合  
>名前：性＋名で構成される  
>金額：量、通貨で構成される  
など
- それ単体で取り扱いたいか

<br>

## ふるまいの実装
例えば、金額は合算することができるから金額クラスは加算(Add)メソッドを持つことができる。  
その際、通貨が異なる場合には合算できず例外を投げるなどのふるまい(ルール)を持たせることができる。  
逆にそのオブジェクトができないことは、ふるまいとして定義されない。  
金額の例だと、加算はできても乗算はできない。  

<br>

## 値オブジェクトを採用する理由
 - 表現力を増やす  
 プリミティブな変数では、それが何を表しているかが分かりにくい
 ```c#:title
 int money = 1000; // 1000円なのか1000ドルなのか分からない
 //※この場合、変数名から判断するしかないが、変数名からも分からない

 Money money = new Money(1000,"USD");  // 1000ドルであることが分かる
 ```
 - 不正な値を存在させない  
 プリミティブな変数では、それが表現しているモノのルールに沿っているかが分からない。
 ```c#:title
 int money = -1000; // 金額にマイナスを設定させたくないが設定できてしまう

 Money money = new Money(-1000,"USD");  // この時点でエラーにできる
 ```
 - 誤った代入を防ぐ  
 - ロジックの散在を防ぐ  
 オブジェクトに関するルールは、クラス内に持てるので、各コードにルールが散在することは減る。

 
