# 依存関係と階層化
## 依存関係
### オブジェクトのインスタンス化によってコードの適応性が損なわれる例
```c#:title
public class AccountController
{
    private readonly SecurityService securityService;
    public AccountController()
    {
        this.securityService = new  SecurityService();
    }

    [HttpPost]
    public void ChangePassword(Guid userId, string newPassword)
    {
        var userRepository = new UserRepository();
        User user = userRepository.GetById(userId);
        this.securityService.ChangeUserPassword(user, newPassword);
    }
}
```
問題点
1. AcountControllerがSecurityServiceとUserRepositoryの実装に永遠に依存する  
AccountController内で直接SecurityServiceとUserRepositoryを参照しているので、参照先クラスで修正があった場合に、その影響を受けてしまう。
2. SecurityServiceとUserRepositoryの依存先がAccountControllerの暗黙的な依存先になっている  
仮にSecurityService内で、SessionFactoryのようなクラスを参照していた場合、AccountControllerはそのクラスも参照していることになる。
3. AccountControllerのユニットテストが難しくなっている  
AccountController内でSecurityServiceとUserRepositoryをNewしているので、外部からモックなどで置き換えることができない。
4. SecurityService.ChangeUserPassword()がクライアントにUserオブジェクトの読み込みを要求する  

解決策  
- 1.3の問題に対する解決策(実際は2も解決する)  
依存性の注入(DI)
- 4の問題に対する解決策  
メソッドの再設計
```c#:title
public class AccountController
{
    // インターフェースにして、コンストラクタで外部から実態を受け取る
    private readonly ISecurityService securityService;
    public AccountController(ISecurityService securityService, IUserRepository userRepository)
    {
        this.securityService = securityService;
        this.userRepository = userRepository;
    }
    [HttpPost]
    public void ChangePassword(Guid userId, string newP、ssword)
    {
        // ServiceクラスにRepository機能を委譲する
        this.securityService.ChangeUserPassword(userId, newPassword);
    }
}

public class SecurityService : ISecurityService
{
    private readonly IUserRepository userRepository;
    public AccountController(IUserRepository userRepository)
    {
        this.userRepository = userRepository;
    }

    public void ChangePassword(Guid userId, string newPassword)
    {
        User user = userRepository.GetById(userId);
        user.ChangeUserPassword(newPassword);
    }
}
```

## 階層化
### 2層アーキテクチャ
ユーザーインターフェイス層とデータアクセス層の2層に分かれる。  
![レイヤーイメージ](image/2%E5%B1%A4%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3.png)  

1. ユーザーインターフェイス層  
- ユーザーインターフェイス層の実行責任  
    - ユーザーがアプリケーションを操作するための手段を提供する。
    - データと情報をユーザーに表示する。
    - ユーザーからクエリやコマンドの形でリクエストを受け取る。
    - ユーザー入力を検証する。  

    各レイヤーは、**その上のレイヤーが依存する機能の抽象化とその実装**との組み合わせによって構成される。

2. データアクセス層
- データアクセス層の実行責任
    - データに対するクエリを処理する
    - リレーショナルモデルとの間でオブジェクトモデルのシリアライズとデシリアライズを行う

3. 適しているケースと適さないケース  
- 適しているケース
    - 単純な検証以外にアプリケーションのロジックがほとんど、あるいはまったくない。  
    この場合はデータアクセス層またはユーザーインターフェース層で簡単にカプセル化できる。    
    - アプリケーションが主にデータのCRUDを実行する。  
    UIとデータの間にレイヤーが追加されるたびに、データのCRUDはより難しくなる。
    - 時間がない場合。プロトタイプなど。  
- 適していないケース
    - アプリケーションに重要なロジックがある。またはロジックが変更の対象となる。  
    UI層やデータアクセス層にロジックを配置すると、関係ない部分まで変更の影響を受けてしまう。
    - 近い将来に2つのレイヤーでは収まらなくなることが確実である。

### ３層アーキテクチャ  
UI層とデータアクセス層の間にビジネスロジック層を持つ。  
![レイヤーイメージ](../../../D:/note/AdaptiveCode/image/3%E5%B1%A4%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3.png)  

1. ビジネスロジック層　　
- ビジネスロジック層の実行責任  
    - UI層からのコマンドを処理する
    - ビジネスプロセス、ルール、ワークフローのモデルとしてビジネスドメインを作成する  

## 横断的関心事  
ログの出力やトランザクションの管理など、複数のレイヤーで関心のある事象が存在する。  
それらに対処するもっとも一般的な方法が、AOP(アスペクト指向プログラミング)である。  
属性を付与することで、共通的に対処することが可能である。

## CQS(コマンド／クエリ分離)
すべてのオブジェクトメソッドはコマンドかクエリのどちらかにすべきという考え方。  
呼び出し順を入れ替える際の変更容易性を整理している。  
クエリは容易、コマンドは慎重に。
- コマンド  
システムの状態を変更することが可能だが、戻り値を返してはならない。
- クエリ  
システムの状態を変更してはならないが、戻り値を返してよい。  

## CQRS(コマンド／クエリ責務分離)
CQSの考え方をアーキテクチャレベルで適用したもの。  
ただデータを呼び出すクエリならば、UI層から直接データアクセス層を呼んでも問題ない。  
コマンドの場合は、ビジネスロジック層を経由してデータアクセス層を呼ぶようにする。  
コマンドとクエリで、レイヤー構造が非対称になる。(コマンド側：３層　クエリ側：２層)  
![CQRS](../../../D:/note/AdaptiveCode/image/CQRS.png)