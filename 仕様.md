# 仕様  
## 仕様とは  
オブジェクトの評価を行うオブジェクト  
簡単な評価であればオブジェクト自身が行うことで問題ないが、複雑になった場合にオブジェクトから処理を切り離し、仕様クラスとして独立させる

## 複雑な評価処理を仕様クラスとして切り出す 

以下の例では、アプリケーションサービスにドメインの知識(サークルが満員かどうかを評価する)が漏れている
```c#:title
public class CircleApplicationService 
{ 
    private readonly ICircleRepository circleRepository; 
    private readonly IUserRepository userRepository; 
     
    public void Join(CircleJoinCommand command) 
    { 
        // アプリケーションサービスにドメインの知識(メンバーの上限)が漏れているのでダメ
        var circleId = new CircleId(command.CircleId);
        var circle = circleRepository.Find(circleId); 
        var users = userRepository.Find(circle.Members);
        // サークルに所属しているプレミアムユーザの人数により上限が変わる 
        var premiumUserNumber = users.Count(user => user.IsPremium);
        var circleUpperLimit = premiumUserNumber < 10 ? 30 : 50; 
        if (circle.CountMembers() >= circleUpperLimit) 
        { 
            throw new CircleFullException( circleId); 
        } 
    } 
}
```  

これを解決するためにドメインオブジェクト(Circle)に知識を移動したが、  
ドメインオブジェクトがリポジトリの操作をしてしまうので、これもよくない
```c#:title
public class Circle 
{ 
    //プレミアムユーザの人数を探したいが保持しているのはUserIdのコレクションだけ
    public List <UserId> Members { get; private set; } 
    
    public bool IsFull(IUserRepository userRepository) 
    { 
        // ドメイン内にドメインの知識が収まっているが、リポジトリの操作をしているのダメ
        var users = userRepository.Find(Members);
        var premiumUserNumber = users.Count(user => user.IsPremium); 
        var circleUpperLimit = premiumUserNumber < 10 ? 30 : 50; 
        return CountMembers() >= circleUpperLimit; 
    } 
}
```

これを解決するために、サークルが満員かに関する知識を仕様として別クラスに切り出した
```c#:title
/// サークルが満員かに関する知識を仕様として別クラスに切り出した
public class CircleFullSpecification
{
    private readonly IUserRepository userRepository;

    public CircleFullSpecification(IUserRepository userRepository)
    {
        this.userRepository = userRepository;
    }

    public bool IsSatisfiedBy(Circle circle)
    {
        var users = userRepository.Find(circle.Members);
        var premiumUserNumber = users.Count(user => user.IsPremium);
        var circleUpperLimit = premiumUserNumber < 10 ? 30 : 50;
        return circle.CountMembers() >= circleUpperLimit;
    }
}

public class CircleApplicationService
{
    private readonly ICircleRepository circleRepository;
    private readonly IUserRepository userRepository;

    public void Join(CircleJoinCommand command)
    {
        // アプリケーションサービスにドメインの知識が漏れていない
        var circleId = new circleId(command.circleId);
        var circle = circleRepository.Find(circleId);
        var CircleFullSpecification = new CircleFullSpecification(userRepository);
        if (CircleFullSpecification.IsSatisfiedBy(circle))
        {
            throw new CircleFullException(circleId);
        }
    }
}
```

/// さらに、仕様クラスでのリポジトリの使用を避けるために、ファーストコレクションを作成する
```c#:title
/// 仕様クラスでのリポジトリの使用を避けるために、ファーストコレクションを作成する
public class CircleMembers
{
    private readonly User owner;
    private readonly List<User> Members;

    public CircleMembers(circleId id, User owner, List<User> members)
    {
        Id = id;
        this.owner = owner;
        this.members = members;
    }

    public CircleId Id {get;}
    
    public int CountMembers()
    {
        return members.Count() + 1;
    }

    public int CountPremiumMembers(bool cntainsOwner = true)
    {
        var premiumUserNumber = members.Count(member => member.IsPremium);
        if (cntainsOwner)
        {
            return premiumUserNumber + (owner.IsPremium ? 1 : 0);
        }
        else
        {
            return premiumUserNumber;
        }
    }
}

public class CircleFullSpecification
{
    // リポジトリの操作を排除できた
    public bool IsSatisfiedBy(CircleMembers members)
    {
        var premiumUserNumber = members.CountPremiumMembers(false);
        var circleUpperLimit = premiumUserNumber < 10 ? 30 : 50;
        return members.CountMembers() >= circleUpperLimit;
    }
}

public class CircleApplicationService
{
    private readonly ICircleRepository circleRepository;
    private readonly IUserRepository userRepository;

    public void Join(CircleJoinCommand command)
    {
        var circleId = new circleId(command.circleId);
        var circle = circleRepository.Find(circleId);
        // ファーストコレクションへのデータ詰め替え処理が発生する
        var owner = userRepository.Find(circle.owner);
        var members = userRepository.Find(circle.Members);
        var circleMembers = new CircleMembers(circle.Id, owner, members);
        var CircleFullSpecification = new CircleFullSpecification(circleMembers);
        if (CircleFullSpecification.IsSatisfiedBy(circle))
        {
            throw new CircleFullException(circleId);
        }
    }
}
```

## 仕様とリポジトリを組み合わせる  
リポジトリに仕様を引き渡すことで、検索を行う。  
以下の抽出条件もった検索処理を実装する例で確認する。  
<br>

例）おすすめサークルを検索する  
おすすめサークルは、『直近１か月以内に決済されたサークル』『所属メンバー数が１０名以上』と定義する  

以下の実装だと、検索条件がリポジトリ側に漏れている
```c#:title
public interface ICircleRepository
{
    public List<Circle> FindRecommended(Datatime now);
}

public class CircleApplicationService
{
    private readonly Datatime now;

    public CircleGetRecommendResult GetRecommend(CircleGetRecommendRequest request)
    {
        // 検索条件がリポジトリの実装に依存している
        var recommendCircles = circleRepository.FindRecommended(now);
        return new CircleGetRecommendResult(recommendCircles);
    }
}
```
これを解決するために、仕様クラスを作成し、仕様クラスを使ってリポジトリが検索できるようにする。

```c#:title
// 仕様クラスのインターフェース
public interface ISpecification<T>
{
    public bool IsSatisfiedBy(T value);
}

// おすすめサークルかを評価する仕様クラス
public class CircleRecommendSpecification : ISpecification<Circle>
{
    private readonly Datatime executeDatetime;

    public CircleRecommendSpecification(Datatime executeDatetime)
    {
        this.executeDatetime = executeDatetime;
    }

    public bool IsSatisfiedBy(Circle circle)
    {
        if (circle.CountMembers() < 10)
        {
            return false;
        }
        return circle.Created > executeDatetime.AddMonths(-1);
    }
}

public interface ICircleRepository
{
    // リポジトリは仕様のインターフェースを受け取り結果を返す
    // 仕様をインターフェースにすることで、仕様ごとにリポジトリにメソッドを追加する必要がなくなる
    public List<Circle> Find(ISpecification<Circle> spcification);
}

public class CircleApplicationService
{
    private readonly ICircleRepository circleRepository;
    private readonly Datatime now;

    public CircleGetRecommendResult GetRecommend(CircleGetRecommendRequest request)
    {
        var circleRecommendSpecification = new CircleRecommendSpecification(now);
        // リポジトリに仕様を引き渡して抽出
        var recommendCircles = 
            circleRepository.Find(circleRecommendSpecification)
            .Takr(10)
            .ToList();
        return new CircleGetRecommendResult(recommendCircles);
    }
}
```