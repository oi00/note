# テスト(SmallTest)

# 何のためにテストする？

## テストはプログラムのふるまいを確認するため

 　確認のタイミングは、ふるまいを”変えたとき”と”変えていないとき”の２つが存在する

- 変えたとき

機能追加や機能修正による仕様変更

- 変えないとき

リファクタリングによる構造変更

## 変化の頻度が加速することは確定している

AIによる実装が可能になったため

つまり必然的に**テストの実施回数も増加する**ことは確定している

人間がテストするのでは回数に限界が発生する

## よってテストも機械に実施させることが必須になる

テストコードの生成とその保守が必須になる

テストがコードになるということは、

- テストコードの書き方を理解する必要があり
- より良い方法を模索する必要があり
- より良いテストの実装を目指す必要がある（リファクタリング）

## コードは資産ではなく負債

したがって、テストコードも必要最低限の作成に留める必要があり、最小限の保守コストで最大限の価値を産めるようにする必要がある

# テストコードを書くために必要なことは？

## テストコードが書きやすいコード、書きにくいコードが存在する

DB接続している、依存先が多い…etc

基本的にテスト対象の設計に問題がある場合は、テストコードも書きにくい

つまり、テストコードを書くことで、悪い設計であることを回避することができる（⚠️良い設計かは判断できない）

## テストコードを先に書いて、それが通るコードを書いてしまえば良い（TDDの目的の半分）

テストを先に書くことで、テストコードに適応したコードを強制的に作れる仕組みを作る

TDDはこの仕組みを活用して、テストコード作成(Red)→仮実装(Green)→リファクタリング(Green)の流れで作業を進めている

TDDでやりたいことの1つは、まず”想定するふるまいを定義し、それに沿って実装する”、つぎに”ふるまいを変えずに、**より良い構造を模索する**”である。

## このふるまいを先に定義することがエージェントAIが実装するうえでのガイドラインとなる

アプローチとしては、KiroやSpecKitなどで実現される仕様駆動開発と似ている。

ふるまいを自然言語ではなくコードで表現することにより、曖昧さを排除することが可能になる。

# SmallTest(≒単体テスト)の定義

- 1単位のふるまいを検証する
- 実行時間が短い
- 他のテスト・ケースから隔離された状態で実施されること

単体テストという言葉は人によって定義が微妙に異なる。

そのためテストサイズ（Small,Midium,Large）という、テストの実行場所や実行時間に注目した分割方法がある。

- Smallテスト：単一のプロセス内で実行
- Mediumテスト：単一のマシン上で実行
- Largeテスト：実行には制約がない

## テスト(SmallTest)の構造

1. 準備(Arrange)
    
    テストデータの準備、テスト対象の準備
    
2. 実行(Act)
    
    テスト対象のメソッド実行
    
3. 確認(Assert)
    
    実行結果の確認
    

これは、テストコードでも同じように表現する(AAAパターン)

SmallTestの定義”実行されるのは1つのふるまい”から考えると基本的には

- 実行は1行になる
- 各フェーズは1ケースで1回ずつ
- 準備フェーズが1番大きくなる

と言える。逆にそうなっていない場合は、テスト対象の設計に問題がある可能性が高い