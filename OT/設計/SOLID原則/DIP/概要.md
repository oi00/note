# 依存関係逆転の法則

## 概要

依存関係の向きは、制御可能である。
変化しにくいものへ依存するように、依存の方向性を管理することが重要である。

## 具体的なイメージ

before

```csharp
[利用側] ────依存────> [具象クラス]
```

利用側が具象クラスに依存している

after

```csharp
[利用側] ────依存────> [インターフェース] <────実装──── [具象クラス]
```

利用側が定義したインターフェースに具象クラスが依存している

利用側にやりたいことがあって、それのやり方がコロコロ変わるなら、
利用側はやりたいことだけ定義して、それを参照すればいい。

## よく見る使われ方

- Repositoryパターン

```csharp
[データ取得] ────依存────> [インターフェース] <────実装──── [取得の具体処理]
```

データ永続化の方法は多岐にわたる（DBからデータ取得したい場合もあれば、ファイルから取得したい場合もある）
末端のデータ永続化の詳細に依存しないようにするための仕組み

テスト時にはMockを活用し、実際のデータ永続化処理にDBなどを使用しなくても該当処理をテストすることが可能になる

- Port & Adapter

Repositoryパターンでやっていることを、外部サービス全てに対して適用しただけ
データの永続化だけではなく、帳票やログの出力なんかにも同じことをする

## DI(依存性の注入)

抽象クラスに依存する利用側のクラスは、外部から具象クラスを注入される必要がある。
これが依存性の注入にあたる。

```
[Application]
  OrderService
        ↓
  IOrderRepository  ← 抽象（業務側が定義）
        ↑
[Infrastructure]
  SqlOrderRepository ← 詳細
```

```csharp
public sealed class OrderService
{
    private readonly IOrderRepository _orderRepository;

    // ★ 外部から依存を注入
    public OrderService(IOrderRepository orderRepository)
    {
        _orderRepository = orderRepository;
    }

    public void ChangeOrder(OrderId id)
    {
        var order = _orderRepository.FindById(id);

        // 業務ロジック（省略）

        _orderRepository.Save(order);
    }
}

public interface IOrderRepository
{
    Order FindById(OrderId id);
    void Save(Order order);
}

public sealed class Order
{
    public OrderId Id { get; }

    public Order(OrderId id)
    {
        Id = id;
    }
}

public readonly struct OrderId
{
    public int Value { get; }

    public OrderId(int value)
    {
        Value = value;
    }
}
```

DIの方法は、コンストラクタ、セッター、フィールドとあるが、コンストラクタが推奨される。
セッターではオブジェクトがミュータブルになってしまい、フィールドではDIフレームワークの機能に依存したりするため。