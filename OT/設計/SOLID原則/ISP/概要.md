# インターフェース分離の原則

## 概要

クライアントは、自分が使用しないメソッドへの依存を強制されるべきではない

**インターフェース実装先で使わないメソッドがないようにインターフェースを分けるべき**

## 守られない場合に発生する問題

実際は関係のない変更に影響を受けてしまう

疎結合を目指して抽象に依存していたはずが、影響を受ける範囲が広がっている

## 原則が破られるパターン

- 一部の具象クラスしか関係ないのに、既存の抽象クラスにメソッドを追加してしまう。
    
    新しい抽象クラスを作るのをサボった結果、既存に足してしまう。
    
    結果、抽象クラス（あるいはインターフェース）が**共通の役割を超えた責務**を持ち始める
    
    関係のない具象クラスが、空実装、例外スロー、意味のないデフォルト実装を持つことになる
    
- 概念先行で抽象する
「 Repository はこういうものだよね」という概念で、RepositoryのインターフェースにDB更新に関係する処理を全てまとめる。
    
    本来はユースケースごとに、作成、更新、管理、削除など、使用するインターフェースが限られているので、インターフェースを分けたほうがよい場合などもある。
    
- 実装側の共通化を優先してしまう
    
    具象クラスの処理が同じなので、共通のインターフェースを切る。
    
    単純に処理が同じだからということが、同じことを表現しているとは限らないため、共通のインターフェースにしてよいかの判断材料にはならない。(SRPの考え方に似ている)
    

## 違反を検知するタイミング

- 設計時
- テスト実装時
    
    主にテストに必要なモックを作成するタイミング。テストに関係のないメソッドのモックを実装したり、そもそもモックしないメソッドが多い場合は、ISPに違反している可能性が高い
    

## ISPはカプセル化を崩す？

ISPを「メソッド単位で過剰に分割」すると、結果としてカプセル化（情報隠蔽）が弱まることがある

```csharp
public interface IOrderCreator
{
	void CreateOrder();
}
public interface IOrderValidator
{
	void Validate();
}
public interface IOrderSaver
{
	void Save();
}
```

```csharp
public class OrderService :
	IOrderCreator,
	IOrderValidator,
	IOrderSaver
{
// 内部では一連の業務として処理している
}
```

この問題は、本来 CreateOrder() は、検証、永続化、を含む「1つの業務操作」のはずだが、利用側が Validate → Save など、**内部手順を意識して呼び分けられる**

これは、**業務上の不変条件や手順が外部に漏れている**状態

このように、**クライアントの関心ではなく、実装手順や内部構造**を元にインターフェース分離を実施すると、カプセル化が壊れる。

以下のように業務単位に切ることで、カプセル化を守る必要がある。

```csharp
public interface IOrderApplicationService
{
	void PlaceOrder();
}
public interface IOrderCancellationService
{
	void CancelOrder();
}
```

```csharp
public class OrderService :
    IOrderApplicationService,
    IOrderCancellationService
{
    // 内部では複雑な処理をまとめて隠している
}
```

ISPを、インターフェースを小さくすること、内部メソッドをインターフェースに切り出すことのように理解しないことが重要。

## インターフェースの役割

**結論：依存関係を制御する**ために存在する

以下の構造では、実装変更、技術変更、責務分割が、全て利用側に波及する

```csharp
[利用側] ────依存────> [具象クラス]
```

以下の構造にすると、利用側は契約(インターフェース)にだけ依存し、実装の変更、差し替えは具象クラスに閉じ込められる。

```csharp
[利用側] ────依存────> [インターフェース] <────実装──── [具象クラス]
```

これにより、変更に強い構造が表現できる