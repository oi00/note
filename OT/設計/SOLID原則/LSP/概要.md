# LSP：リスコフの置換原則

> **SがTのサブタイプ（派生型）であるならば、プログラムのT型のオブジェクトが現れるすべての場所で、T型のオブジェクトをS型のオブジェクトに置き換えても、プログラムの望ましい性質（振る舞いの正確さなど）が変化しないようにしなければならない**
> 

## **1. LSP とは何か（まず結論）**

**リスコフの置換原則（LSP）とは、**

**「継承が正しく使われているか」を判断するための原則**です。

一言で言うと、

> スーパークラスの型として使っているオブジェクトは、
> 

> どのサブクラスに置き換えても、
> 

> プログラムの意味や正しさが壊れてはいけない
> 

という原則です。

---

## **2. 何についての原則か**

- 対象：**OOP における継承**
- 焦点：
    - クラス構造ではない
    - メソッドの存在でもない
    - **振る舞い（意味・契約）**

つまり LSP は、

> 「extends しているかどうか」ではなく
> 

> 「
> 
> 
> **is-a の関係として本当に成立しているか**
> 

を問う原則です。

---

## **3. 「置き換え可能」とはどういうことか**

「置き換え可能」とは、次を満たすことです。

- スーパークラス前提で書かれたコードが
- サブクラスに置き換わっても
    - 呼び方を変えなくてよい
    - 例外対応を増やさなくてよい
    - 意味的な期待が壊れない

**型は同じでも、意味が変わったらアウト**です。

---

## **4. LSP 違反の典型例**

### **① スーパークラスのメソッドが「実質的に呼べなくなる」**

```jsx
Base では呼べるはずのメソッドが、
Sub にすると例外を投げる／条件付きでしか呼べない
```

例：

- save() を override して UnsupportedOperationException
- 「特定の条件でないとエラー」になる

👉 **「呼べる前提」が壊れている**

---

### **② サブクラスで事前条件を強める**

```jsx
Base: amount >= 0 なら OK
Sub : amount >= 1000 でないと NG
```

Base 型として正しい呼び方が、

Sub にするとエラーになる。

👉 **Base の契約を守っていない**

---

### **③ 状態によって突然使えなくなる**

- Base：何度呼んでも安全
- Sub ：2回目以降は例外

👉 Base 型として書かれたコードが壊れる。

---

### **④ 振る舞いの意味が変わる（サイレントな破壊）**

- 呼び出しは成功する
- しかし期待した効果がない（no-op など）

👉 **呼べるが、呼ぶ意味がなくなっている**

---

## **5. 「スーパークラスでサブクラスの型を見て分岐する」問題**

```jsx
if (this is SubA) { ... }
else if (this is SubB) { ... }
```

これは強い LSP 違反シグナルです。

理由：

- Base がサブクラスの存在を知っている
- 「Base として扱えば OK」という前提が崩れる
- 実質的にポリモーフィズムを否定している

👉 この時点で、

- 継承の切り方が間違っている
- もしくは継承ではない

---

## **6. LSP を守る設計の方向性**

### **基本方針**

- **Base は契約を定義する**
- **Sub はその契約の範囲内で振る舞う**
- 差分は override に任せる
- 型判定はしない

それでも条件分岐したくなったら、次を疑う。

> 「この違いは、本当に is-a の違いか？」
> 

多くの場合、

- Strategy
- Policy
- Composition

で表現すべき差分です。

---

## **7. OCP・継承との関係**

- LSP が破られると
    - if / 型チェックが増える
    - Base の修正が増える
- 結果として
    - **OCP が守れなくなる**

つまり、

> LSP は「OCP を成立させる前提条件」
> 

です。

---

## **8. 実務で使えるチェックリスト**

レビューや設計時に、次を自問する。

- 「Base 型として書かれた既存コードは、
    
    Sub に置き換えても一切修正不要か？」
    
- 「例外 handling を増やしていないか？」
- 「この Sub は Base の“使い方の説明書”を変えていないか？」
- 「注意書きが必要になっていないか？」

1つでも怪しければ、LSP 違反を疑う。

---

## **9. まとめ（短く言うと）**

- LSP は **継承の正当性を判断する原則**
- ポイントは **置き換え可能性**
- 型ではなく **振る舞い・契約**を見る
- 「呼べなくなる」「意味が変わる」は危険信号
- LSP が壊れると OCP も壊れる

---

# 継承より移譲

## **1. 前提：OOPにおける継承とは何か**

継承は、

- スーパークラスに共通処理を書く
- サブクラスで差分を override する

という形で、**「型の違い」で振る舞いの違いを表現する仕組み**です。

このとき設計者は、

> 「このサブクラスはスーパークラスとして扱っても問題ないか？」
> 

つまり **LSP（リスコフの置換原則）** を常に満たす必要があります。

---

## **2. 継承が難しくなりやすい理由（LSPの観点）**

継承を使うと、次の前提が暗黙に課されます。

- サブクラスは、スーパークラスの契約を壊してはいけない
- 振る舞いを「少しだけ」変えたつもりでも、
    - 呼び出せなくなるメソッド
    - 期待される前提条件・事後条件の破壊
        
        が起きやすい
        

結果として、

> 「継承できているが、置換できていない」
> 

という状態が発生しやすくなります。

これは設計者の注意不足というより、

**継承という仕組み自体が、人間に高度な設計判断を要求する**ためです。

---

## **3. 継承とSRP（単一責任の原則）の関係**

ここが非常に重要なポイントです。

### **スーパークラスが抱えがちなもの**

継承設計では、スーパークラスに以下が集まります。

- 全サブクラス共通の処理
- 「今は」共通だと思っている処理
- サブクラス差分を吸収するための制御構造
- 将来拡張のための抽象メソッドやフック

その結果、スーパークラスは

- 共通仕様が変わったとき
- 差分の種類が増えたとき
- 拡張方針が変わったとき

など、**複数の理由で変更される**クラスになります。

これは明確に **SRP 違反**です。

---

## **4. サブクラス側もSRPを壊しやすい**

サブクラスも実は単純ではありません。

サブクラスは、

- 自身の差分を表現する
- スーパークラスの前提・制御構造を理解する
- 他のサブクラスとの整合性を保つ

という複数の責務を背負います。

結果として、

> 「〇〇という種類の処理」
> 

> ＋「継承構造を壊さない責務」
> 

を同時に持つことになり、ここでも SRP が崩れやすくなります。

---

## **5. 継承の本質的な制約**

継承には、構造的な制約があります。

- 差分は **サブクラスという単位でしか表現できない**
- 差分の組み合わせに弱い
- 後から「別の観点の差分」を足しづらい

つまり、

> 差分が増えるほど、クラス階層が歪む
> 

という問題を内包しています。

---

## **6. コンポジションの考え方**

コンポジションは、発想が根本的に異なります。

- 型の違いで分けない
- **変更理由ごとに責務を分解する**
- その小さな責務を **組み合わせて振る舞いを作る**

ここで重要なのは、

> コンポジションとは
> 

> 「他のオブジェクトを保持し、振る舞いを委譲する設計」
> 

であり、DI（依存性の注入）は

**その設計を支えるための技法**にすぎない、という点です。

---

## **7. コンポジションとSRPの相性**

コンポジションでは、

- Validation は Validator
- 永続化は Persister
- 特殊ルールは Rule

のように、

> 「変更理由」と「クラス」が1対1
> 

になります。

そのため、

- ある仕様変更が
- どのクラスに影響するかが明確
- 影響範囲が局所化される

結果として、SRP を自然に満たしやすくなります。

---

## **8. なぜ「継承よりコンポジション」と言われるのか**

近年の OOP で言われているのは、

- 「継承は使うな」ではなく
- **「継承でしか表現できないかを強く疑え」**

というスタンスです。

理由は、

- 継承は
    - LSP
    - SRP
    - OCP
        
        を同時に満たす難易度が高い
        
- コンポジションは
    - 差分
    - 責務
    - 拡張
        
        を構造として分離できる
        

ためです。

---

## **9. まとめ（他者に伝えるときの要点）**

- 継承は「差分をサブクラスで表現する設計」
- その構造上、
    - LSP を破りやすく
    - SRP に反しやすい
- 特にスーパークラスは責務が肥大化しやすい
- コンポジションは
    - 変更理由ごとに責務を分解し
    - 振る舞いを組み合わせる設計
- その結果、
    - 保守性
    - 拡張性
    - 理解容易性
        
        が高くなる