# 依存関係のコントロール
## 依存とは  
あるオブジェクトからあるオブジェクトを参照している状態  
![依存関係](image/%E4%BE%9D%E5%AD%98%E9%96%A2%E4%BF%821.png)  

## 依存関係逆転の原則  
1. 上位レベルのモジュールは下位レベルのモジュールに依存してはならない、どちらのモジュールも抽象に依存すべきである。  
⇒IUserRepositoryを作成することで、どちらのクラスも抽象クラス(インターフェース)に依存するようになった
2. 抽象は、実装の詳細に依存してはならない。実装の詳細が抽象に依存すべきである。  
⇒<font color="Red">ここよくわからない</font>

![依存関係逆転の原則](image/%E4%BE%9D%E5%AD%98%E9%96%A2%E4%BF%82%E9%80%86%E8%BB%A2%E3%81%AE%E5%8E%9F%E5%89%87.png)

## 依存関係をのコントロール  
- Service Locatorパターン  
    - ServiceLocatorクラスからインスタンスを取得する
    - ServiceLocatorクラスには事前にインスタンスを登録しておく  

    デメリット
    - 依存関係がクラスを見ただけではわかりにくい
    - テストの維持が難しい
```C#:title
public class UserApplicationService
{
    private readonly IUserRepository userRepository;

    public UserApplicationService()
    {
        this.userRepository = ServiceLocator.Resolve<IUserRepository>();
    }
}
```  
<br>

- IoC Container(DI Container)パターン  
Dependency Injection(依存の注入)　　クラス外部から依存先の情報を提供する。  
例ではコンストラクタで依存先のクラスを渡している(コンストラクタインジェクション)
```c#:title
public class UserApplicationService 
{ 
    private readonly IUserRepository userRepository; 
    public UserApplicationService(IUserRepository userRepository) 
    { 
        this.userRepository = userRepository;
    } 
}
```

ただし、上記の例だとインスタンス化のたびにコードに依存するオブジェクトについての記述が必要になる。  
それを回避するために、依存関係をあらかじめ設定し、インスタンス生成を自動で行ってくれるIoC Containerを使用する。
```c#:title
// IoC Container
// 依存解決の設定を登録する 
var serviceCollection = new ServiceCollection(); 
serviceCollection.AddTransient<IUserRepository,InMemoryUserRepository>(); 
serviceCollection.AddTransient<UserApplicationService>();

// インスタンスはIoC Container経由で取得する 
var provider = serviceCollection.BuildServiceProvider(); 
var userApplicationService = provider.GetService<UserApplicationService>();
```